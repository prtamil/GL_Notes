
# Profile Title

> **“Senior backend / staff engineer focused on distributed systems, scalability, and cloud runtime architecture.”** ✅

This matches:

- Backend roles
    
- Platform roles
    
- SRE-heavy roles
    

Without sounding unicorn-ish.

# Language 
```txt
Languages:
- Python (primary): distributed services, async workers, platform tooling
- Go: high-throughput services, infra components
- JavaScript (Node.js): APIs, internal tooling

```
## Interview alignment (this matters more than resume)

When asked:

> “Which language are you strongest in?”

You answer:

> “Python is my primary language. I use Go when latency, throughput, or concurrency becomes critical. I’ve also worked with Node.js where it makes sense, but I’m primarily a backend systems engineer.”

That sentence alone puts you in **Staff-level framing**.


## How this widens your fishing net (real impact)

### You now qualify for:

- Senior Backend Engineer (Python/Go)
    
- Staff Engineer (Distributed Systems)
    
- Platform / Infra-heavy Backend roles
    
- ML-adjacent backend roles (without being ML engineer)
    
- SRE-with-coding roles (product companies only)
    

### You automatically avoid:

- Frontend-heavy fullstack traps
    
- Pure DevOps/YAML roles
    
- JS-only shops that undervalue seniors
    

---

## What hiring managers actually think (brutal truth)

- **Python-only senior** → “Good, but maybe slow / high-level”
    
- **Go-only senior** → “Strong, but narrow”
    
- **Python + Go** → “This person understands systems”
    
- **Python + Go + JS (clearly framed)** → “This person can adapt without losing depth”
    

That’s the sweet spot.


