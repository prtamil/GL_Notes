## Techworld with Nana [Kubernetes Course]

### 1. Basic Arch Overview

Master => workers

Master componets

1.  Api server => Entry point of k8s cluster (ui,api,cli)
2.  Controller Manager => Keeps track of what happens in cluster
3.  Scheduler => ensures Pods placement
4.  etcd => Kubernetes backing store.

Master - (virtualNetwork) - Workers

Declarative -> is == should

Controller Manager checks => desired state == actual state

### 2. Kubernetes Components

#### Node and Pod

Node => VM/ActualMachine
Pod

1. Smallest unit of K8s
2. Abstraction over container [replace multiple container tech]
3. Each pod gets its own ip address
4. each pod communicate within itself by ip address.
5. ephemeral

#### Service and Ingress

Service:

1. Permanent IP
2. attached to pod.
3. Lifecycle not connected to POD.

Types

1. External Service
   1. NodeIpAddress:Port
2. Internal Service

Ingress:

1. External Service goes to Ingress and Forwarding to service.

#### Configmap and Secret

for Ex. Database URL usually in the built application.

configmap:

- External configuration of your application.

Secret:

- Used to store secret data. [passwords and keys]
- base64 encoded.

using env variable we cann accees configmap and secrert

#### Volume.

Data Storage. -> Volumes
Attached to pod for Storage.
local or remote.

k8s dont manage data persistance. we have to manage it.

#### Deployment and Stateful Set.

replicas are connected to same service.
service is mostly dns name.
service is also load balancer.

Blueprint of Apps Pods => Deployment.

Database cant be replicated via deployment.
reason: State.
StatefulSet :Replicas+DataStorage [App like DBs], Handles state inconsistency[R/W]

Deployment => Stateless apps such as webserver.
StatefulSet => Stateful Apps such as Database

Advice:
Working in DB [StatefulSet] seems very tedious in K8s Cluser.
so we host DB outside and has communicate from k8s.

### 3. Kubernetes Architecture.

#### Node :Worker Machine of K8s Cluster.

1. each node has multiple pods
2. 3 Processes must be installed in every node.
   1. container runtime [docker]
   2. kubelet [interacts with both container and node]
   3. kubeproxy [forward request service to pods]
3. Worker Nodes do the actual work

#### Master Processs / Master Nodes [Need multiple masters for actual setup]

4 Processes.

1. API Server
   1. cluster gateway
   2. gatekeeper for auth
2. Scheduler
   1. handles/decides where to put the pod?
   2. it only decides
   3. kubelet actuall does.
3. Controller Manager.
   1. detect cluster state changes [pod down]
   2. And reschedules the changes [ask scheduler to make pod up]
   3. flow: Controller Manager -> Scheduler -> Kubelet.
4. etcd [Key/Val Storage]
   1. cluster changes stored in etcd.
   2. has answers for
      1. what resources are available
      2. did cluster state change.
      3. is cluster healthy
   3. Application data is NOT stored in etcd.
      1. data of databases. etc..

#### Example setup

2 master node , 3 worker nodes
can add master/node cluster

### 4. Benifits of Kubernetes,

k8s data flow.
out url => ingress => Services.

1. everycomponent is replicated, loadbalanced, nobottleneck.

disaster recovery.
etcd -> store remote storage -> admin need to take care.
no db stored in etcd -> dbdata -> remote storage -> admin need to take care.

self healing k8s

### 5. Kubernetes in Practice

minikube, kubectl, minikube cluster.

Minikube

- master & worker in single node
- 1 node k8 cluster.

kubectl -> cmdline for k8s cluster interaction.

### 6. Kubectl basic Commands

#### Create

1.  kubectl create -
2.  cant create pods . use deployment.

Deployment

> kubectl create deployment name --image=image [--dry-run] [options]
> kubectl get deployment
> kubectl edit deployment [name] -> Opens yaml in editor.[Autogenerated yaml with default values]
> kubectl delete deployment [name] -> dels replicaset/pods
> kubectl rollout restart deployment <deployment name> //restart pods . noway directly restart pods. we need to restart deployment.
> kubectl apply -f deploymentfname.yaml (k8s knows create or update)
> kubectl delete -f fname.yaml

Debugging

> kubectl logs [pod name]
> kubectl exec --stdin --tty pod-name -- /bin/bash
> -> --(doubledash) seperates arguments diff kubectl arguments vs inside pod arguments.
> kubectl describe [pods]
> kubectl get pod -o wide [for more info]
> kubectl get pod -l name=app [Displays pods only name app]

Deployment:

    1. blueprint for creating pods.
    2. most basic configuration
       1. name
       2. image
    3. rest default

podname (kubectl get pods ) =>
[podname]-[replicasetid]-[podownid]

replicaset is managing the replicas of a pod.

Layers of Abstraction:

Deployment manages a --=> ReplicaSet Manages a => Pod is Abstraction of a Container.

### 7. YAML Configuration files

#### Configuration has 3 parts

1. Metadata

   1. name

2. Specification

   1.

3. status [Automated and edited by k8s]
   1. used for actual state = desired state
   2. stored in etcd.

Store config file with code (Infrastructure as code.)

> kubectl get deployment [depname] -o yaml [get deployment in yaml format complete info we can get status ]

#### template

1.  has own metadata
2.  and spec section.

#### Labels and Selectors

1. any key value pair for components

labels:

1. provide key value pair of data
2. Do not affect the semantics of the core system.

selector

1. way of expressing how to select objects based on their labels.
2. 2 types of selector
   1. Equality-based.
   2. Set-based

Example:

Say we have service and we want to select pods
so we label pod as name=mypod and in service selector we give selector name:mypod
service we automatically selects by label.

why selector.

1. selector should have flexible to select based on key and pair.
2. we can label flexibily by providing non predefined
3. selector is way we can select flexible non pre defined labels.

#### Deployment

```yaml
apiversion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
spec:
  replicas: 2
```

Services

### 8. Complete Application Setup with Kubernetes components

workflow
browser -> externel service -> pod [express] -> internal service -> pod [db]

cmds

> kubectl get all [all resources?]
> kubectl get all | grep name [see pods,service,deployment,replicaset]
> kubectl get pod --watch [Watch status]

secret -> key/val -> val -> base64 encoded

deployment secret refer -> [valueFrom -> secretKeyRef].

yaml
--- {3 dashed} for document seperation multiple documents.

```yaml
ports:  <linking service port to pod port>
   - protocol: TCP
     port: 1023   <port of service>
     targetPort: 3100  <port of pod port>
```
